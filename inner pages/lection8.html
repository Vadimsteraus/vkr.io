<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>Лекция 7.2</title>
  <link rel='stylesheet' href='./assets/css/bootstrap.css'>
<link rel='stylesheet' href='./assets/css/font-awesome.css'>
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="shortcut icon" href="./assets/icon/favicon.ico" type="image/x-icon" />

</head>
<body>
  

  <div class="preloader" id="page-preloader">
    <div class="loader"></div>
  </div>
<!-- partial:index.partial.html -->
<nav class="navbar navbar-expand-lg navbar-dark fixed-top bg-dark">
  <a class="logo_text" href="./main_page.html"><img class="logo" src="./assets/icon/logo.svg" alt="logo"><p class="navbar-brand">Электронное пособие по проектированию и дизайну ИС</p></a>
  <button
    class="navbar-toggler"
    type="button"
    data-toggle="collapse"
    data-target="#navbarCollapse"
    aria-controls="navbarCollapse"
    aria-expanded="false"
    aria-label="Toggle navigation"
    onClick="addFilters()"
  >
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="navbarCollapse">
    <ul class="navbar-nav mr-auto sidenav" id="navAccordion">
      <li class="nav-item">
        <a class="nav-link" href="./main_page.html">Главная</a>
      </li>
      <li class="nav-item">
        <a class="nav-link nav-link-collapse nav-link-show collapsed"
        href="#"
        id="hasSubItems"
        data-toggle="collapse"
        data-target="#collapseSubItems1"
        aria-controls="collapseSubItems1"
        aria-expanded="true">
        Лекции
        <span class="sr-only">(current)</span></a>
        <ul class="nav-second-level collapse collapse show" id="collapseSubItems1" data-parent="#navAccordion">
          <li class="nav-item">
            <a class="nav-link" href="./lection1.html">
              <span class="nav-link-text">
                Лекция 1. Основные понятия и определения ИС. Жизненный цикл информационных систем
              </span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="./lection2.html">
              <span class="nav-link-text">Лекция 2.  Модели жизненных циклов информационных систем.</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="./lection3.html">
              <span class="nav-link-text">Лекция 3. Технологии сбора информации.</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="./lection4.html">
              <span class="nav-link-text">Лекция 4. Иерархическая структура работ.</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="./lection5.html">
              <span class="nav-link-text">Лекция 5. Сетевой график выполнения работ.</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" id="16" href="./lection6.html">
              <span class="nav-link-text">Лекция 6. Техническое задание.</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="./lection7.html">
              <span class="nav-link-text">Лекция 7.1. Сервисно - ориентированные архитектуры.</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link active" href="#" id="17">
              <span class="nav-link-text">Лекция 7.2. Анализ интересов клиента. Выбор вариантов решений.</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="./lection9.html">
              <span class="nav-link-text">Лекция 8. Особенности информационного и прочего программного обеспечения для информационных систем.</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="./lection10.html">
              <span class="nav-link-text">Лекция 9.1. Основные понятия качества информационной системы.</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="./lection11.html">
              <span class="nav-link-text">Лекция 9.2. Оценка качества информационных систем.</span>
            </a>
          </li>
        </ul>
      </li>
      <li class="nav-item">
        <a
          class="nav-link nav-link-collapse"
          href="#"
          id="hasSubItems"
          data-toggle="collapse"
          data-target="#collapseSubItems2"
          aria-controls="collapseSubItems2"
          aria-expanded="true"
        >Тесты</a>
        <ul class="nav-second-level collapse" id="collapseSubItems2" data-parent="#navAccordion">
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">Контрольная работа по теме "Структурный анализ ИС, основные модели построения ИС"</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">Контрольная работа по теме "Принципы построения IDEFO, диаграммы"</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">Контрольная работа по теме "..."</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">Контрольная работа по теме "..."</span>
            </a>
          </li>
          <li class="nav-item">
        </ul>
      </li>
      <li class="nav-item">
        <a
        class="nav-link nav-link-collapse"
        href="#"
        id="hasSubItems"
        data-toggle="collapse"
        data-target="#collapseSubItems3"
        aria-controls="collapseSubItems3"
        aria-expanded="true"
        href="#">Практические работы</a>
        <ul class="nav-second-level collapse" id="collapseSubItems3" data-parent="#navAccordion">
          <li class="nav-item">
            <a class="nav-link" href="./practice1.html">
              <span class="nav-link-text">Практическая работа №1. Жизненный цикл информационной системы</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="./practice2.html">
              <span class="nav-link-text">Практическая работа №2. Системный и структурный анализ</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="./practice3.html">
              <span class="nav-link-text">Практическая работа №3. Категории специалистов</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="./practice4.html">
              <span class="nav-link-text">Практическая работа №4. Анкета и интервью</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="./practice5.html">
              <span class="nav-link-text">Практическая работа №5. Классификация информационных систем</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="./practice6.html">
              <span class="nav-link-text">Практическая работа №6. Иерархическая структура работ</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="./practice7.html">
              <span class="nav-link-text">Практическая работа №7. Сетевой график</span>
            </a>
          </li>          
          <li class="nav-item">
            <a class="nav-link" href="./practice8.html">
              <span class="nav-link-text">Практическая работа №8. Техническое задание</span>
            </a>
          </li>          
          <li class="nav-item">
            <a class="nav-link" href="practice9.html">
              <span class="nav-link-text">Практическая работа №9. Определения "SOAP" и "Интересы клиента"</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="practice10.html">
              <span class="nav-link-text">Практическая работа №10. Модель IDEF0</span>
            </a>
          </li>      
          <li class="nav-item">
            <a class="nav-link" href="practice11.html">
              <span class="nav-link-text">Практическая работа №11. Описание моделей с использованием нотаций IDEF0 и ETC</span>
            </a>
          </li>   
          <li class="nav-item">
            <a class="nav-link" href="practice12.html">
              <span class="nav-link-text">Практическая работа №12. ТЭО</span>
            </a>
          </li>  
          <li class="nav-item">
            <a class="nav-link" href="practice13.html">
              <span class="nav-link-text">Практическая работа №13. Реинжиниринг методом интеграции</span>
            </a>
          </li> 
        </ul>
      </li>
      <li class="nav-item">
        <a
          class="nav-link nav-link-collapse"
          href="#"
          id="hasSubItems"
          data-toggle="collapse"
          data-target="#collapseSubItems4"
          aria-controls="collapseSubItems4"
          aria-expanded="false"
        >Самостоятельные <br> работы</a>
        <ul class="nav-second-level collapse" id="collapseSubItems4" data-parent="#navAccordion">
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">
                Самостоятельная работа №1. Организация и методы сбора информации. Анализ 
                предметной области. Основные понятия системного и 
                структурного анализа
              </span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">Самостоятельная работа №2. Основные понятия и определения ИС. Жизненный цикл 
                информационных систем</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">Самостоятельная работа №3. Постановка задачи обработки информации. Основные виды, 
                алгоритмы и процедуры обработки информации, модели и 
                методы решения задач обработки информации.</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">Самостоятельная работа №4. Основные модели построения информационных систем, их 
                структура, особенности и области применения.</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">Самостоятельная работа №5. Сервисно - ориентированные архитектуры. Анализ 
                интересов клиента. Выбор вариантов решений.</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">Самостоятельная работа №6. Методы и средства проектирования информационных систем. Case-средства для моделирования деловых процессов 
                (бизнес-процессов). Инструментальная среда–структура, 
                интерфейс, элементы управления.</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">Самостоятельная работа №7. Принципы построения модели IDEF0: контекстная 
                диаграмма, субъект моделирования, цель и точка зрения.</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">Самостоятельная работа №8. Диаграммы IDEF0: диаграммы декомпозиции, диаграммы 
                дерева узлов, диаграммы только для экспозиции (FEO).</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">Самостоятельная работа №9. Работы (Activity). Стрелки (Arrow). Туннелирование 
                стрелок. Нумерация работ и диаграмм. Каркас диаграммы.</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">Самостоятельная работа №10. Слияние и расщепление моделей/</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">Самостоятельная работа №11. Особенности информационного, программного и 
                технического обеспечения различных видов информационных 
                систем. Экспертные системы. Системы реального времени.</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">Самостоятельная работа №12. Оценка экономической эффективности информационной 
                системы. Стоимостная оценка проекта. Классификация типов 
                оценок стоимости: оценка порядка величины, концептуальная 
                оценка, предварительная оценка, окончательная оценка, 
                контрольная оценка.</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">Самостоятельная работа №13. Основные процессы управления проектом. Средства 
                управления проектами.</span>
            </a>
          </li>
        </ul>
      </li>
      <li class="nav-item">
        <a
        class="nav-link nav-link-collapse"
        href="#"
        id="hasSubItems"
        data-toggle="collapse"
        data-target="#collapseSubItems5"
        aria-controls="collapseSubItems5"
        aria-expanded="true"
        href="#">Справочные Материалы</a>
        <ul class="nav-second-level collapse" id="collapseSubItems5" data-parent="#navAccordion">
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">Глоссарий</span>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">
              <span class="nav-link-text">Итоговый тест</span>
            </a>
          </li>
    </ul>
      </li>
    </ul>
  </div>
</nav>

<main class="content-wrapper" id="all">
  <div class="container-fluid">
    <div class="change_page">
      <a href="./lection7.html" id="arrow-back"><img title="Лекция 7.1" src="./assets/icon/arrow-left.svg"  alt="back"></a>
      <a id="next-button" href="./lection9.html"><img title="Лекция 8" src="./assets/icon/arrow-right.svg" alt="next"></a>
    </div>

    <h1>Анализ интересов клиента. Выбор вариантов решений</h1>

    <a href="../inner pages/assets/files_to_download//Лекция 7.2 Анализ интересов клиента. Выбор вариантов решений.docx" class="download"><img style="width: 4vw;position: relative;margin-right: 0vw !important;box-shadow: unset !important;border-radius: 0px !important;" src="./assets/icon/docx.svg">Скачать лекцию в виде файла </a>
    <h2></h2>
    <p class="text-vvod">Сервис-ориентированная архитектура (SOA)</p>
    <p class="text-vvod">
      Сервис-ориентированная архитектура (service-oriented architecture, SOA) придумана в конце 1980-х. Она берёт своё начало в идеях, изложенных в CORBA, DCOM, DCE и других документах. О SOA написано много, есть несколько её реализаций. Но, по сути, SOA можно свести к нескольким идеям, причём архитектура не диктует способы их реализации:
      <ul>
        <li>Сочетаемость приложений, ориентированных на пользователей.</li>
        <li>Многократное использование бизнес-сервисов.</li>
        <li>Независимость от набора технологий.</li>
        <li>Автономность (независимые эволюция, масштабируемость и развёртываемость).</li>
      </ul>
    </p>
    <p class="text-vvod">
      SOA — это набор архитектурных принципов, не зависящих от технологий и продуктов, совсем как полиморфизм или инкапсуляция.
    </p>
    <p class="text-vvod">
      В этой лекции рассмотрены следующие паттерны, относящиеся к SOA:
      <ul>
        <li>Общая архитектура брокера объектных запросов (CORBA).</li>
        <li>Веб-сервисы.</li>
        <li>Очередь сообщений.</li>
        <li>Сервисная шина предприятия (ESB).</li>
        <li>Микросервисы.</li>
      </ul>
    </p>
    <h2><b>Общая архитектура брокера объектных запросов (CORBA)</b></h2>
    <p class="text-vvod">
      В 1980-х началось активное использование корпоративных сетей и клиент-серверной архитектуры. 
    </p>
    <p class="text-vvod">
      Возникла потребность в стандартном способе взаимодействия приложений, которые созданы с использованием разных технологий, исполняются на разных компьютерах и под разными ОС. Для этого была разработана CORBA. 
    </p>
    <p class="text-vvod">
      Это один из стандартов распределённых вычислений, зародившийся в 1980-х и расцветший к 1991 году.
    </p>
    <p class="text-vvod">
      Стандарт CORBA был реализован несколькими вендорами. Он обеспечивает:
      <ul>
        <li>Не зависящие от платформы вызовы удалённых процедур (Remote Procedure Call).</li>
        <li>Транзакции (в том числе удалённые!).</li>
        <li>Безопасность.</li>
        <li>События.</li>
        <li>Независимость от выбора языка программирования.</li>
        <li>Независимость от выбора ОС.</li>
        <li>Независимость от выбора оборудования.</li>
        <li>Независимость от особенностей передачи данных/связи.</li>
        <li>Набор данных через язык описания интерфейсов (Interface Definition Language, IDL).</li>
      </ul>
    </p>
    <p class="text-vvod">
      Сегодня CORBA всё ещё используется для разнородных вычислений. Например, он до сих пор является частью Java EE, хотя начиная с Java 9 будет поставляться в виде отдельного модуля.
    </p>
    <h2>Принцип работы</h2>
    <p class="text-vvod">
      <b>ORB</b> (Object Request Broker, то есть брокер объектных запросов) — это объектная шина. Она позволяет объектам напрямую производить и отвечать на запросы других объектов, расположенных как локально (на одном компьютере, но в разных процессах), так и удаленно.
    </p>
    <p class="text-vvod">
      <b>Вендор</b> — это физическое или юридическое лицо, которое производит и/или поставляет товары под собственным брендом. Вендор может не производить продукцию самостоятельно, его основная задача — продвижение товара и его распределение. (Данное определение про вендора не относится к CORBA. Оно здесь для понимания)
    </p>
    <p class="text-vvod">
      <b>Stub-интерфейс</b> - клиентский интерфейс, обеспечивает взаимосвязь клиента с ORB. Прикладная программа клиента через посредника stub, как статической части программы клиента, посылает в запросе параметры, которым сопоставляются соответствующие описания интерфейса из репозитория (хранилище простыми словами) интерфейсов.
    </p>
    <p class="text-vvod">
      <b>Skeleton</b> - это представитель клиента в адресном пространстве сервера
    </p>
    <p class="text-vvod">
      <b>IDL</b> (Язык описания интерфейсов) - Язык спецификаций для описания интерфейсов, синтаксически похожий на описание классов в языке C++
    </p>
    <p class="text-vvod">
      Сначала нам нужно получить брокер объектных запросов (Object Request Broker, ORB), который соответствует спецификации CORBA. Он предоставляется вендором и использует языковые преобразователи (language mappers) для генерирования «заглушек» (stub) и «скелетов» (skeleton) на языках клиентского кода. С помощью этого ORB и определений интерфейсов, использующих IDL (аналог WSDL), можно на основе реальных классов генерировать в клиенте удалённо вызываемые классы-заглушки (stub classes). А на сервере можно генерировать классы-скелеты (skeleton classes), обрабатывающие входящие запросы и вызывающие реальные целевые объекты.
    </p>
    <div class="img"><img src="./assets/img/lection8/1.png" alt="illustration1"></div>
    <p class="text-vvod">
      Вызывающая программа (caller) вызывает локальную процедуру, реализованную заглушкой.
      <ul>
        <li>Заглушка проверяет вызов, создаёт сообщение-запрос и передаёт его в ORB.</li>
        <li>Клиентский ORB шлёт сообщение по сети на сервер и блокирует текущий поток выполнения.</li>
        <li>Серверный ORB получает сообщение-запрос и создаёт экземпляр скелета.</li>
        <li>Скелет исполняет процедуру в вызываемом объекте.</li>
        <li>Вызываемый объект проводит вычисления и возвращает результат.</li>
        <li>Скелет пакует выходные аргументы в сообщение-ответ и передаёт его в ORB.</li>
        <li>ORB шлёт сообщение по сети клиенту.</li>
        <li>Клиентский ORB получает сообщение, распаковывает и передаёт информацию заглушке.</li>
        <li>Заглушка передаёт выходные аргументы вызывающему методу, разблокирует поток выполнения, и вызывающая программа продолжает свою работу.</li>
      </ul>
    </p>
    <h2>Достоинства</h2>
    <ul>
      <li>Независимость от выбранных технологий (не считая реализации ORB).</li>
      <li>Независимость от особенностей передачи данных/связи.</li>
    </ul>
    <h2>Недостатки</h2>
    <p class="text-vvod">
      Независимость от местоположения: клиентский код не имеет понятия, является ли вызов локальным или удалённым. Звучит неплохо, но длительность задержки и виды сбоев могут сильно варьироваться. Если мы не знаем, какой у нас вызов, то приложение не может выбрать подходящую стратегию обработки вызовов методов, а значит, и генерировать удалённые вызовы внутри цикла. В результате вся система работает медленнее.
    </p>
    <p class="text-vvod">
      Сложная, раздутая и неоднозначная спецификация: её собрали из нескольких версий спецификаций разных вендоров, поэтому (на тот момент) она была раздутой, неоднозначной и трудной в реализации.
    </p>
    <p class="text-vvod">
      Заблокированные каналы связи (communication pipes): используются специфические протоколы поверх TCP/IP, а также специфические порты (или даже случайные порты). Но правила корпоративной безопасности и файрволы зачастую допускают HTTP-соединения только через 80-й порт, блокируя обмены данными CORBA.    
    </p>
    <p class="text-vvod"></p>
    <h2><b>Веб-сервисы</b></h2>
    <p class="text-vvod">
      На данный момент можно найти применение для CORBA, но нужно было уменьшить количество удалённых обращений, чтобы повысить производительность системы. 
    </p>
    <p class="text-vvod">
      Также требовался надёжный канал связи и более простая спецификация обмена сообщениями.
    </p>
    <p class="text-vvod">
      И для решения этих задач в конце 1990-х начали появляться веб-сервисы.
    </p>
    <p class="text-vvod">
      <b>Нужен был надёжный канал связи, поэтому:</b>
      <ul>
        <li>HTTP стал по умолчанию работать через порт 80.</li>
        <li>Для обмена сообщениями начали использовать платформо-независимый язык (вроде XML или JSON).</li>
      </ul>
    </p>
    <p class="text-vvod">
      <b>Нужно было уменьшить количество удалённых обращений, поэтому:</b>
      <ul>
        <li>Удалённые соединения стали явными, так что теперь мы всегда знаем, когда выполняется удалённый вызов.</li>
        <li>Вместо многочисленных удалённых вызовов объектов мы обращаемся к удалённым сервисам, но гораздо реже.</li>
      </ul>
    </p>
    <p class="text-vvod">
      <b>Нужно было упростить спецификацию обмена сообщениями, поэтому:</b>
      <ul>
        <li>Первый черновик SOAP появился в 1998-м, стал рекомендацией W3C в 2003-м, после чего превратился в стандарт. SOAP вобрал в себя некоторые идеи CORBA, вроде слоя для обработки обмена сообщениями и «документа», определяющего интерфейс с помощью языка описания веб-сервисов (Web Services Description Language, WSDL).</li>
        <li>Рой Филдинг в 2000-м описал REST в своей диссертации «Architectural Styles and the Design of Network-based Software Architectures». Его спецификация оказалась гораздо проще SOAP, поэтому вскоре REST обогнал SOAP по популярности.</li>
        <li>Facebook (Добавь сюда пометку) разработал GraphQL в 2012-м, а публичный релиз выпустил в 2015-м. Это язык запросов для API, позволяющий клиенту строго определять, какие данные сервер должен ему отправить, не больше и не меньше.</li>
      </ul>
    </p>
    <p class="text-vvod">
      Веб-сервисы можно публиковать, находить и использовать стандартным образом вне зависимости от технологий. — Microsoft 2004, Understanding Service-Oriented Architecture
    </p>
    <div class="img"><img src="./assets/img/lection8/2.png" alt="illustration2"></div>
    <p class="text-vvod">
      Благодаря микросервисам мы перешли в парадигме SOA от удалённого вызова методов объекта (CORBA) к передаче сообщений между сервисами.
    </p>
    <p class="text-vvod">
      Но нужно понимать, что в рамках SOA веб-сервисы — не просто API общего назначения, всего лишь предостаовляющие CRUD-доступ к базе данных через HTTP. В каких-то случаях эта реализация может быть полезной, но ради целостности ваших данных необходимо, чтобы пользователи понимали лежащую в основе реализации модель и соблюдали бизнес-правила. SOA подразумевает, что веб-сервисы являются ограниченными контекстами бизнес-субдоменов (business sub-domain) и отделяет реализацию от решаемых веб-сервисами задач.
    </p>
    <p class="text-vvod">
      С точки зрения технологий SOA не просто сервисная архитектура, а набор политик, методик и фреймворков, благодаря которым мы предоставляем и получаем нужные сервисы. — Microsoft 2004, Understanding Service-Oriented Architecture
    </p>
    <h2><b>Достоинства</b> SOA</h2>
    <p class="text-vvod">
      <ul>
        <li>Независимость набора технологий, развёртывания и масштабируемости сервисов.</li>
        <li>Стандартный, простой и надёжный канал связи (передача текста по HTTP через порт 80).</li>
        <li>Оптимизированный обмен сообщениями.</li>
        <li>Стабильная спецификация обмена сообщениями.</li>
        <li>Изолированность контекстов доменов (Domain contexts).</li>
      </ul>
    </p>
    <h2>Недостатки</h2>
    <p class="text-vvod">
      <ul>
        <li>Разные веб-сервисы тяжело интегрировать из-за различий в языках передачи сообщений. Например, два веб-сервиса, использующих разные JSON-представления одной и той же концепции.</li>
        <li>Синхронный обмен сообщениями может перегрузить системы.</li>
      </ul>
    </p>
    <h2><b>Сервисная шина предприятия (ESB)</b></h2>
    <p class="text-vvod">
      Сервисная шина предприятия использовала веб-сервисы уже в 1990-х, когда они только развивались (быть может, некоторые реализации сначала использовали CORBA?).
    </p>
    <p class="text-vvod">
      ESB возникла во времена, когда в компаниях были отдельные приложения. Например, одно для работы с финансами, другое для учёта персонала, третье для управления складом, и т. д., и их нужно было как-то связывать друг с другом, как-то интегрировать. Но все эти приложения создавались без учёта интеграции, не было стандартного языка для взаимодействия приложений (как и сегодня). Поэтому разработчики приложений предусматривали конечные точки для отправки и приёма данных в определённом формате. Компании-клиенты потом интегрировали приложения, налаживая между ними каналы связи и преобразуя сообщения с одного языка приложения в другой.
    </p>
    <p class="text-vvod">
      Очередь сообщений может упростить взаимодействие приложений, но она не способна решить проблему разных форматов языков. Впрочем, была сделана попытка превратить очередь сообщений из простого канала связи в посредника, доставляющего сообщения и преобразующего их в нужные форматы/языки. ESB стал следующей ступенью в естественной эволюции простой очереди сообщений.
    </p>
    <div class="img"><img style="width: 40% !important" src="./assets/img/lection8/3.png" alt="illustration3"></div>
    <p class="text-vvod">
      В этой архитектуре используется модульное приложение (composite application), обычно ориентированное на пользователей, которое общается с веб-сервисами для выполнения каких-то операций. В свою очередь, эти веб-сервисы тоже могут общаться с другими веб-сервисами, впоследствии возвращая приложению какие-то данные. Но ни приложение, ни бэкенд-сервисы ничего друг о друге не знают, включая расположение и протоколы связи. Они знают лишь, с каким сервисом хотят связаться и где находится сервисная шина.
    </p>
    <p class="text-vvod">
      Клиент (сервис или модульное приложение) отправляет запрос на сервисную шину, которая преобразует сообщение в формат, поддерживаемый в точке назначения, и перенаправляет туда запрос. Всё взаимодействие идёт через сервисную шину, так что если она падает, то с ней падают и все остальные системы. То есть ESB — ключевой посредник, очень сложный компонент системы.
    </p>
    <p class="text-vvod">
      Это очень упрощённое описание архитектуры ESB. Более того, хотя ESB является главным компонентом архитектуры, в системе могут использоваться и другие компоненты вроде доменных брокеров (Domain Broker), сервисов данных (Data Service), сервисов процессной оркестровки (Process Orchestration Service) и обработчиков правил (Rules Engine). Тот же паттерн может использовать интегрированная архитектура (federated design): система разделена на бизнес-домены со своими ESB, и все ESB соединены друг с другом. У такой схемы выше производительность и нет единой точки отказа: если какая-то ESB упадёт, то пострадает лишь её бизнес-домен.
    </p>
    <div class="img"><img src="./assets/img/lection8/4.png" alt="illustration4"></div>
    <p class="text-vvod">
      Главные обязанности ESB:
      <ul>
        <li>Отслеживать и маршрутизировать обмен сообщениями между сервисами.</li>
        <li>Преобразовывать сообщения между общающимися сервисными компонентами.</li>
        <li>Управлять развёртыванием и версионированием сервисов.</li>
        <li>Управлять использованием избыточных сервисов.</li>
        <li>Предоставлять стандартные сервисы обработки событий, преобразования и сопоставления данных, сервисы очередей сообщений и событий, сервисы обеспечения безопасности или обработки исключений, сервисы преобразования протоколов и обеспечения необходимого качества связи.</li>
      </ul>
    </p>
    <p class="text-vvod">
      Создавая структуры связи между разными процессами, мы видели много продуктов и подходов, в которых применяются очень развитые механизмы связи. Хороший пример — сервисные шины предприятий, часто включающие в себя сложные средства маршрутизации сообщений, хореографии, преобразования и применения бизнес-правил. — Martin Fowler 2014, Microservices
    </p>
    <p class="text-vvod">
      У этого архитектурного паттерна есть положительные стороны. Однако я считаю его особенно полезным в случаях, когда мы не «владеем» веб-сервисами и нам нужен посредник для трансляции сообщений между сервисами, для оркестрирования (управления) бизнес-процессами, использующими несколько веб-сервисов, и прочих задач.
    </p>
    <p class="text-vvod">
      Также рекомендую не забывать, что реализации ESB уже достаточно развиты и в большинстве случаев позволяют использовать для своего конфигурирования пользовательский интерфейс с поддержкой drag & drop.
    </p>
    <h2><b>Достоинства</b></h2>
    <p class="text-vvod">
      <ul>
        <li>Независимость набора технологий, развёртывания и масштабируемости сервисов.</li>
        <li>Стандартный, простой и надёжный канал связи (передача текста по HTTP через порт 80).</li>
        <li>Оптимизированный обмен сообщениями.</li>
        <li>Стабильная спецификация обмена сообщениями.</li>
        <li>Изолированность контекстов домена (Domain contexts).</li>
        <li>Простота подключения и отключения сервисов.</li>
        <li>Асинхронность обмена сообщениями помогает управлять нагрузкой на систему.</li>
        <li>Единая точка для управления версионированием и преобразованием.</li>
      </ul>
    </p>
    <h2><b>Недостатки</b></h2>
    <ul>
      <li>Ниже скорость связи, особенно между уже совместимыми сервисами.</li>
      <li>
        Централизованная логика:
        <ul>
          <li>Единая точка отказа, способная обрушить системы связи всей компании.</li>
          <li>Большая сложность конфигурирования и поддержки.</li>
          <li>Со временем можно прийти к хранению в ESB бизнес-правил.</li>
          <li>Шина так сложна, что для её управления вам потребуется целая команда.</li>
          <li>Высокая зависимость сервисов от ESB.</li>
        </ul>
      </li>
    </ul>
    <h2>Микросервисы</h2>
    <p class="text-vvod">
      В основе микросервисной архитектуры лежат концепции SOA. Назначение у неё то же, что и у ESB: создать единое общее корпоративное приложение из нескольких специализированных приложений бизнес-доменов.
    </p>
    <p class="text-vvod">
      Главное различие микросервисов и шины в том, что ESB была создана в контексте интеграции отдельных приложений, чтобы получилось единое корпоративное распределённое приложение. А микросервисная архитектура создавалась в контексте быстро и постоянно меняющихся бизнесов, которые (в основном) с нуля создают собственные облачные приложения.
    </p>
    <p class="text-vvod">
      То есть в случае с ESB у нас уже были приложения, которые нам не «принадлежат», и поэтому мы не могли их изменить. А в случае с микросервисами мы полностью контролируем приложения (при этом в системе могут использоваться и сторонние веб-сервисы).
    </p>
    <p class="text-vvod">
      Характер построения/проектирования микросервисов не требует глубокой интеграции. Микросервисы должны соответствовать бизнес-концепции, ограниченному контексту. Они должны сохранять своё состояние, быть независимыми от других микросервисов, и потому они меньше нуждаются в интеграции. То есть низкая взаимозависимость и высокая связность привели к замечательному побочному эффекту — уменьшению потребности в интеграции.
    </p>
    <p class="text-vvod">
      Микросервисы — это маленькие автономные сервисы, работающие вместе и спроектированные вокруг бизнес-домена. — Sam Newman 2015, Principles Of Microservices
    </p>
    <p class="text-vvod">
      Главным недостатком архитектуры ESB было очень сложное централизованное приложение, от которого зависели все остальные приложения. А в микросервисной архитектуре это приложение почти целиком убрано.
    </p>
    <p class="text-vvod">
      Ещё остались элементы, пронизывающие всю экосистему микросервисов. Но у них гораздо меньше задач по сравнению с ESB. К примеру, для асинхронной связи между микросервисами до сих пор применяется очередь сообщений, но это лишь канал для передачи сообщений, не более того. Или можно вспомнить шлюз экосистемы микросервисов, через который проходит весь внешний обмен данными.
    </p>
    <p class="text-vvod">
      Сэм Ньюман, автор Building Microservices, выделяет восемь принципов микросервисной архитектуры. Это:
      <ul>
        <li><b>Проектирование сервисов вокруг бизнес-доменов.</b> Это может дать нам стабильные интерфейсы, высоко связные и мало зависящие друг от друга модули кода, а также чётко определённые разграниченные контексты.</li>
        <li><b>Культура автоматизации.</b> Это даст нам гораздо больше свободы, мы сможем развернуть больше модулей.</li>
        <li><b>Скрытие подробностей реализации.</b> Это позволяет сервисам развиваться независимо друг от друга.</li>
        <li><b>Полная децентрализация.</b> Децентрализуйте принятие решений и архитектурные концепции, предоставьте командам автономность, чтобы компания сама превратилась в сложную адаптивную систему, способную быстро приспосабливаться к переменам.</li>
        <li><b>Независимое развёртывание.</b> Можно развёртывать новую версию сервиса, не меняя ничего другого.</li>
        <li><b>Сначала потребитель.</b> Сервис должен быть простым в использовании, в том числе другими сервисами.</li>
        <li><b>Изолирование сбоев.</b> Если один сервис падает, другие продолжают работать, это делает всю систему устойчивой к сбоям.</li>
        <li><b>Удобство мониторинга.</b> В системе много компонентов, поэтому трудно уследить за всем, что в ней происходит. Нам нужны сложные инструменты мониторинга, позволяющие заглянуть в каждый уголок системы и отследить любую цепочку событий.</li>
      </ul>
    </p>
    <div class="img"><img src="./assets/img/lection8/5.png" alt="illustration5"></div>
    <p class="text-vvod">
      Сообщество предпочитает другой подход: умные конечные точки и глупые каналы. Микросервисы, из которых собираются приложения, должны как можно меньше зависеть друг от друга и при этом быть очень тесно связанными — они содержат собственную доменную логику и работают скорее, как фильтры с точки зрения классического Unix: получают запросы, применяют логику и генерируют ответы. Они оркестрируются с помощью простых REST-подобных протоколов, а не сложных протоколов вроде WS-Choreography или BPEL либо какого-то централизованного инструмента. — Martin Fowler 2014, Microservices
    </p>
    <h2><b>Достоинства</b></h2>
    <p class="text-vvod">
      <ul>
        <li>Независимость набора технологий, развёртывания и масштабируемости сервисов.</li>
        <li>Стандартный, простой и надёжный канал связи (передача текста по HTTP через порт 80).</li>
        <li>Оптимизированный обмен сообщениями.</li>
        <li>Стабильная спецификация обмена сообщениями.</li>
        <li>Изолированность контекстов домена (Domain contexts).</li>
        <li>Простота подключения и отключения сервисов.</li>
        <li>Асинхронность обмена сообщениями помогает управлять нагрузкой на систему.</li>
        <li>Синхронность обмена сообщениями помогает управлять производительностью системы.</li>
        <li>Полностью независимые и автономные сервисы.</li>
        <li>Бизнес-логика хранится только в сервисах.</li>
        <li>Позволяют компании превратиться в сложную адаптивную систему, состоящую из нескольких маленьких автономных частей/команд, способную быстро адаптироваться к переменам.</li>
      </ul>
    </p>
    <h2><b>Недостатки</b></h2>
    <p class="text-vvod">
      <ul>
        <li>
          Высокая сложность эксплуатации:
          <ul>
            <li>Нужно много вложить в сильную DevOps-культуру.</li>
            <li>Использование многочисленных технологий и библиотек может выйти из-под контроля.</li>
            <li>Нужно аккуратно управлять изменениями входных/выходных API, потому что эти интерфейсы будут использовать многие приложения.</li>
            <li>Использование «согласованности в конечном счёте» (eventual consistency) может привести к серьёзным последствиям, которые нужно учитывать при разработке приложения, от бэкенда до UX.</li>
            <li>Тестирование усложняется, потому что изменения в интерфейсе могут непредсказуемо влиять на другие сервисы.</li>
          </ul>
        </li>
      </ul>
    </p>
    <h2><b>Заключение</b></h2>
    <p class="text-vvod">
      В последние десятилетия SOA сильно эволюционировала. Благодаря неэффективности прежних решений и развитию технологий сегодня мы пришли к микросервисной архитектуре.
    </p>
    <p class="text-vvod">
      Эволюция шла по классическому пути: сложные проблемы разбивались на более мелкие, простые в решении.
    </p>
    <p class="text-vvod">
      Проблему сложности кода можно решать так же, как мы разбиваем монолитное приложение на отдельные доменные компоненты (разграниченные контексты). Но с разрастанием команд и кодовой базы увеличивается потребность в независимом развитии, масштабировании и развёртывании. SOA помогает добиться такой независимости, упрочняя границы контекстов.
    </p>
    <div class="img"><img src="./assets/img/lection8/6.png" alt="illustration6"></div>
    <p class="text-vvod">Всё дело в слабой взаимозависимости и высокой связности, причём размер компонентов должен быть больше прежнего. </p>
    <p class="text-vvod">Необходимо прагматично оценить свои потребности: используйте SOA, лишь когда это необходимо, поскольку она сильно увеличивает сложность. </p>
    <p class="text-vvod" id="final-text">И если на самом деле вы можете обойтись без SOA, то лучше выберите микросервисы подходящего размера и количества, не больше и не меньше.</p>
  </div>
</main>


<!-- partial -->
  <script src='./assets/js/jquery.js'></script>
<script src='./assets/js/bootstrap.js'></script>
<script  src="./assets/js/script.js"></script>
<script src="./assets/js/addition_scroll_on_page/17.js"></script>

</body>
</html>
